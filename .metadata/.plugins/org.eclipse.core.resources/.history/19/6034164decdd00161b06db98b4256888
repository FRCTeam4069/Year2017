package org.usfirst.frc.team4069.robot;

import org.opencv.core.Mat;
import org.opencv.videoio.VideoCapture;

public class VisionThread implements Runnable {

    public void run() {
        System.out.println("Hello from a thread!");
		VideoCapture vcap = new VideoCapture();
		
	   	
		while (!vcap.open(0)) //(videoStreamAddress, 320,240,7.5))
		{
			//std::cout << "Error connecting to camera stream, retrying " << count<< std::endl;
			//count++;
			//usleep(1000000);
		}
		
		vcap.set(39, 0.1);
		vcap.set(10,1); //, value)
		vcap.set(11, 0);
		Mat frame = new Mat();
		while (true)
		{
			vcap.read(frame);
		}
		//vcap.set( CV_CAP_PROP_EXPOSURE_ABSOLUTE, 0.1);
//		vcap.set(CV_CAP_PROP_BRIGHTNESS, 1);
		//vcap.set(CV_CAP_PROP_CONTRAST, 0);

		
    }

    void findTarget(Mat original, Mat thresholded, Target& targets, const ProgParams& params)
    {

    	vector<Vec4i> hierarchy;
    	vector<vector<Point> > contours;

    	//Find rectangles
    	findContours(thresholded, contours, hierarchy, RETR_EXTERNAL,CHAIN_APPROX_SIMPLE);

    	if(params.Debug)
    	{
    	cout << "Contours: " << contours.size() << endl;
    	cout << "Hierarchy: " << hierarchy.size() << endl;
    	}

    	//run through all contours and remove small contours
    	unsigned int contourMin = 6;
    	for (vector<vector<Point> >::iterator it = contours.begin();
    			it != contours.end();)
    	{
    		//cout<<"Contour Size: "<<it->size()<<endl;
    		if (it->size() < contourMin)
    			it = contours.erase(it);

    		else
    			++it;

    	}

    	//Vector for Min Area Boxes
    	vector<RotatedRect> minRect(contours.size());

    	/// Draw contours
    	Mat drawing = Mat::zeros(original.size(), CV_8UC3);

    	NullTargets(targets);

    	//run through large contours to see if they are our targerts
    	if (!contours.empty() && !hierarchy.empty())
    	{

    		for (unsigned int i = 0; i < contours.size(); i++)
    		{
    			//capture corners of contour
    			minRect[i] = minAreaRect(Mat(contours[i]));

    			if(params.Visualize)
    			{

    				//if(hierarchy[i][100] != -1)
    				//drawContours(original, contours, i, RED, 2, 8, hierarchy, 0,Point());

    				//draw a minimum box around the target in green
    				Point2f rect_points[4];
    				minRect[i].points(rect_points);
    				for (int j = 0; j < 4; j++)
    					line(original, rect_points[j], rect_points[(j + 1) % 4], BLUE, 1, 8);
    			}
    			//define minAreaBox
    			Rect box = minRect[i].boundingRect();

    			double WHRatio = box.width / ((double) box.height);
    			double HWRatio = ((double) box.height) / box.width;

    			//check if contour is vert, we use HWRatio because it is greater that 0 for vert target
    			if ((HWRatio > MinVRatio) && (HWRatio < MaxVRatio))
    			{
    				targets.VertGoal = true;
    				targets.VerticalTarget = box;
    				targets.VerticalAngle = minRect[i].angle;
    				targets.VerticalCenter = Point(box.x + box.width / 2,
    						box.y + box.height / 2);
    				targets.Vertical_H_W_Ratio = HWRatio;
    				targets.Vertical_W_H_Ratio = WHRatio;

    			}
    			//check if contour is horiz, we use WHRatio because it is greater that 0 for vert target
    			else if ((WHRatio > MinHRatio) && (WHRatio < MaxHRatio))
    			{
    				targets.HorizGoal = true;
    				targets.HorizontalTarget = box;
    				targets.HorizontalAngle = minRect[i].angle;
    				targets.HorizontalCenter = Point(box.x + box.width / 2,
    						box.y + box.height / 2);
    				targets.Horizontal_H_W_Ratio = HWRatio;
    				targets.Horizontal_W_H_Ratio = WHRatio;
    			}

    			if (targets.HorizGoal && targets.VertGoal)
    			{
    				targets.HotGoal = true;

    				//determine left or right
    				if (targets.VerticalCenter.x < targets.HorizontalCenter.x) //target is right
    					targets.targetLeftOrRight = 1;
    				else if (targets.VerticalCenter.x > targets.HorizontalCenter.x) //target is left
    					targets.targetLeftOrRight = -1;

    				targets.lastTargerLorR = targets.targetLeftOrRight;

    			}

    			if(params.Debug)
    			{
    				cout<<"Contour: "<<i<<endl;
    				cout<<"\tX: "<<box.x<<endl;
    				cout<<"\tY: "<<box.y<<endl;
    				cout<<"\tHeight: "<<box.height<<endl;
    				cout<<"\tWidth: "<<box.width<<endl;
    				cout<<"\tangle: "<<minRect[i].angle<<endl;
    				cout<<"\tRatio (W/H): "<<WHRatio<<endl;
    				cout<<"\tRatio (H/W): "<<HWRatio<<endl;
    				cout<<"\tArea: "<<box.height*box.width<<endl;
    			}

    			//ID the center in yellow
    			Point center(box.x + box.width / 2, box.y + box.height / 2);
    			line(original, center, center, YELLOW, 3);
    			line(original, Point(320/2, 240/2), Point(320/2, 240/2), YELLOW, 3);

    		}
    		//if(params.Visualize)
    			//imshow("Contours", original); //Make a rectangle that encompasses the target
    	}
    	else
    	{

    		line(original,Point(0,0),Point(0,0),YELLOW,3);
    		line(original,Point(1,1),Point(320/2,240/2),YELLOW,3);

    		cout << "No Contours Found" << endl;
    		targets.targetLeftOrRight = 0;
    	}

    	if(params.Visualize)
    				imshow("Contours", original); //Make a rectangle that encompasses the target

    	pthread_mutex_lock(&matchStartMutex);
    	if (!targets.matchStart)
    		targets.hotLeftOrRight = targets.targetLeftOrRight;
    	pthread_mutex_unlock(&matchStartMutex);

    }

    
    
    public static void main(String args[]) {
        (new Thread(new VisionThread())).start();
    }

}

